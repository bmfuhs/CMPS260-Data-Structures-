<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 2 Programming Assignment</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the no prototype approach.
//       This is what the book uses, so you can copy it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//--------------------------//
// The stack data structure //
//--------------------------//
console.log("The stack data structure");

// 1. Implement the stack data structure described in the book. Instead of
//    using 'let items = [];' use 'var items = []'. Note that this
//    implementation does not use the prototype (see project).

function Stack() {
  // properties and methods go here
  var items = [];

   this.push = function (element) {
     items.push(element);
   };

   this.pop = function() {
     return items.pop();
   };

   this.peek = function (){
     return items [items.length-1];
   };

   this.isEmpty = function(){
     return items.length == 0;
   };

   this.size = function(){
     return items.length;
   };

   this.clear = function(){
     console.log(items.toString());
   };
};

// 2. Write a simple test program that shows your stack works.

var stack = new Stack();
console.log(stack.isEmpty());

stack.push(5);
stack.push(8);

console.log(stack.peek());

stack.push(11);
console.log(stack.size());
console.log(stack.isEmpty);

stack.push(15);

stack.pop();
stack.pop();
console.log(stack.size());
stack.print();

//----------------------------------//
// ECMAScript 6 and the Stack class //
//----------------------------------//
console.log("ECMAScript 6 and the Stack class");

// Skip.



//-------------------------------//
// Solving problems using stacks //
//-------------------------------//
console.log("Solving problems using stacks");

// 1. Use the prompt to ask for a decimal number. Then write a loop that divides
//    the number by two in every iteration and prints the remainder (0 or 1).
//    For example, if the number is 5 the remainder is 1 and the number in the
//    next iteration should be 2 (5/2 rounded down).

function divideBy2 (decNumber) {
  var remStack = new Stack(),
  rem,
  binaryString =''

  while (decNumber > 0) {
    rem = Math.floor(decNumber % 2);
    remStack.push(rem);
    decNumber = Math.floor(decNumber / 2);
  }

  while(!remStack.isEmpty()){
    binaryString += remStack.pop().toString();
  }

  return binaryString;
}
// 2. The algorithm in (1) can be used to convert a decimal number to a binary
//    number but there is one issue. What is the problem?

// If dividing a number by two and storing it in array, it will be in reverse order.

// 3. Solve the problem in (2) using a stack.

function baseConverter(decNumber, base){
  var remStack = new Stack(),
  rem,
  baseString = ''
  digits = '0123456789ABCDEF';

  while (decNumber > 0){
    rem = Math.floor(decNumber % base);
    remStack.push(rem);
    decNumber + Math.floor(decNumber / base);
  }

  while (!remStack.isEmpty()){
    baseString += digits[remStack.pop()];
  }
  return baseString;
}

//--------------------------//
// The queue data structure //
//--------------------------//
console.log("The queue data structure");

// 1. Describe the difference between a stack and a queue. Give one example
//    where a stack is appropriate and one example where a queue is
//    appropriate (that has not yet been discussed in class).

//A queue is an ordered collection of items that follows the FIFO (First In First Out)
//principle. A stack follows the LIFO (Last In First Out) principle, i.e., the element
//inserted at the last is the first element to come out.  Essentially, in a stack we remove
//the item the most recently added; in a queue, we remove the item the least recently added.

//You could use a stack to create an "undo" mechanism in text editors.
//Using jQuery, you could use a queue to allow a series of functions to be asynchronously
//executed on elements in the DOM, and builds up a queue of “steps” that transition
//from one CSS value to another in order to create a smooth animation.

//

//------------------//
// Creating a queue //
//------------------//
console.log("Creating a queue");

// 1. Implement the queue data structure described in the book. Instead of
//    using 'let items = [];' use 'var items = []'. Note that this
//    implementation does not use the prototype (see project).

function Queue() {
  // properties and methods go here
  var item =[];

  this.enqueue = function(element){
    items.push(element);
  };

  this.dequeue = function(){
    return items.shift();
  };

  this.front = function(){
    return items [0];
  };

  this.isEmpty = function(){
    return items.length == 0;
  };

  this.size = function(){
    return items.length;
  };

  this.print = function(){
    console.log(items.toString());
  };
};

// 2. Write a simple test program that shows your queue works.

var queue = newQueue();
console.log(queue.isEmpty());

queue.enqueue("John");
queue.enqueue("Jack");

queue.enqueu("Camila");

queue.print();
console.log(queue.size());
console.log(queue.isEmpty());
queue.dequeue();
queue.dequeue();
quiue.print();

//--------------------//
// The priority queue //
//--------------------//
console.log("The priority queue");

// The following class is used below.

function QueueElement(element, priority) {
  this.element = element;
  this.priority = priority;
}

// 1. Finish the implementation below for the priority queue. Note that this
//    implementation does not use the prototype.

function PriorityQueue() {
  var items = [];

  this.enqueue = function(element, priority) {
    // we need to create a queue element that stores the priority as well
    var queueElement = new QueueElement(element, priority);

    // insert into priority queue (difficult part)
    // note that this should be a min priority queue, meaning a lower value
    // gets priority over a higher value
    // ...
  }
  var added = false;
    // loop through the existing items
    for (var i = 0; i < items.length; i++){
        // if the new priority is less than the priority of the current item
        if (queueElement.priority < items[i].priority){
            items.splice(i, 0, queueElement);
            added = true;
            break;
        }
    }
    if (!added)
    {
        items.push(queueElement);
    }
};
  // this is a helper function that is useful for printing
  this.print = function() {
    for (var i = 0; i < items.length; i++) {
      console.log(`${items[i].element} - ${items[i].priority}`);
    }
  };

  // add the other methods as well
  // ...
  this.print = function()
   {
       for (var i = 0; i < items.length; i++)
       {
           console.log(`${items[i].element} - ${items[i].priority}`);
       }
   };

   this.dequeue = function()
   {
       return items.shift().element;
   };
}

// 2. Write a simple test that makes sure the priority queue works as expected.
 var priorityQueue = new PriorityQueue();
 priorityQueue.enqueue("John", 2);
 priorityQueue.enqueue("Jack", 1);
 priorityQueue.enqueue("Camila", 1);
 priorityQueue.print();


//---------------------------------//
// The circular queue - Hot Potato //
//---------------------------------//
console.log("The circular queue - Hot Potato");

// 1. Finish the implementation for the hot potato game. nameList contains the
//    names of the participants, and num is how many times the potato is passed
//    before a participant is ejected from the game (the one that holds the
//    potato). Note that this is effectively a simulation of the game.

function hotPotato(nameList, num) {

  var queue = new Queue();


 for (let i=0; i<nameList.length; i++){
   queue.enqueue(nameList[i]);
 }

 var eliminated = '';
 while (queue.size() > 1){
   for (let i=0; i<num; i++){
     queue.enqueue(queue.dequeue());
   }
   eliminated = queue.dequeue();
   console.log(eliminated + 'was eliminated from the Hot Potato game.');
 }
 return queue.dequeue();
}

// 2. Test the code in (1).
var names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];
var winner = hotPotato(names, 7);

console.log('The winner is:' + winner);



</script>
</head>
<body>
  See console!
</body>
</html>
