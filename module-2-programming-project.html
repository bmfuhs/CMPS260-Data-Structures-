<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 2 Programming Project</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the prototype approach.
//       This is not what the book uses, so you have to convert it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//---------//
// Project //
//---------//
console.log("Project");

// 1. Implement the stack data structure using the prototype.

// 2. It is possible to use a stack to check if the number of parentheses in a
//    string is balanced, meaning there are as many opening parentheses as
//    closing ones. In addition, we can also make sure that each opening
//    parenthesis precedes a closing parenthesis. Implement this algorithm.
//    HINT: When encountering '(' push to the stack and when encountering ')'
//    pop from the stack.

function isBalanced(str) {
  // check the parentheses in str
}

// 3. Write a simple test program that shows your implementation in the
//    previous question works.

//code listed below
var isBalancedParenthesis = (str) => {

    return !str.split('').reduce((uptoPrevChar, thisChar) => {
        if(thisChar === '(' || thisChar === '{' || thisChar === '[' ) {
            return ++uptoPrevChar;
        } else if (thisChar === ')' || thisChar === '}' || thisChar === ']') {
            return --uptoPrevChar;
        }

        return uptoPrevChar
    }, 0);
}

// Test Cases
console.log(isBalancedParenthesis("[()]{}{[()()]()}"));  // returns true
console.log(isBalancedParenthesis("[{()()}({[]})]({}[({})])((((((()[])){}))[]{{{({({({{{{{{}}}}}})})})}}}))[][][]"));  // returns true
console.log(isBalancedParenthesis("({(()))}}"));  // returns false

// 4. Implement the queue data structure using the prototype.

// 5. Create a queue that stores edibles, that can be either fruits or
//    vegetables. Use the constructor below to create the edible and store a
//    few of each kind in the queue (at least 3 of each).

function Edible(name, isFruit) {
  this.name = name;
  this.isFruit = isFruit; // if not fruit, it must be a vegetable
  this.toString = function() {
    return "Edible: " + this.name + " Fruit: " + this.isFruit;
  };
}

// 6. Create two more queues: one for fruits and one for vegetables. For this
//    question, only create them (and leave them empty).

// 7. Dequeue all the elements from the edible queue and enqueue them in the
//    appropriate queue, either for fruits or vegetables.

// 8. Print the final contents to the console, showing that your code works.

//code listed below...

class Queue {
  constructor(){
    this.elements = [];
  }
  enqueue(element) {
     // to add element to the queue
     this.elements.push(element);
   }
   dequeue() {
     // to remove element from queue
     if(this.isEmpty())
        return "Underflow";
     return this.elements.shift();
   }
   front() {
     // to return first element
     if(this.isEmpty())
        return "No elements in Queue";
     return this.elements[0];
   }
   isEmpty() {
   // to know if the queue is empty or not
   return this.elements.length == 0;
   }
   showQueue() {
   //to print all the elements of queue
   var str = "";
   for(var i = 0; i < this.elements.length; i++)
      str += this.elements[i] +" "; return str;
    }
  }
  function Edible(name, isFruit) {
    this.name = name;
    this.isFruit = isFruit; // if not fruit, it must be a vegetable
    this.toString = function() {
      return "Edible: " + this.name + " Fruit: " + this.isFruit + "\n";
    };
  }

  // creating new queue
  var q = new Queue();

  // creating 3 elements to store in the queue
  var element1 = new Edible("Mango" , true);
  var element2 = new Edible("Banana" , false);
  var element3 = new Edible("Tomato" , false);

  // adding elements in queue
  q.enqueue(element1);
  q.enqueue(element2);
  q.enqueue(element3);

  // printing all the elements of queue
  console.log(q.showQueue());

  // creating 2 more queues
  var vegetables = new Queue();
  var fruits = new Queue();


</script>
</head>
<body>
  See console!
</body>
</html>
